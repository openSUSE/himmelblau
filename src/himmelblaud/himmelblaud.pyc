#!/usr/bin/python3
import socket
import os
import argparse
import logging
from systemd.journal import JournalHandler
from configparser import ConfigParser
from pathlib import Path
import json
from enum import Enum
import random
from msal import PublicClientApplication

DEFAULT_CONFIG_PATH = '/etc/himmelblau/himmelblau.conf'
DEFAULT_CONFIG_DIR = '/etc/himmelblau/himmelblau.d'
DEFAULT_SOCK_PATH = '/var/run/himmelblaud/socket'

class ConfigError(Exception):
    pass

class AzureError(Enum):
    INVALID_CRED = 0xC3CE
    REQUIRES_MFA = 0xC39C
    INVALID_USER = 0xC372
    NO_CONSENT   = 0xFDE9
    NO_SECRET    = 0x6AD09A

class Himmelblaud:
    def __init__(self, configfile, debuglevel):
        self.configfile = configfile
        self.logger = logging.getLogger(__name__)
        # Send the logs to systemd
        journald_handler = JournalHandler()
        journald_handler.setFormatter(logging.Formatter(
            '[%(levelname)s] %(message)s'
        ))
        self.logger.addHandler(journald_handler)
        self.logger.setLevel(debuglevel)
        self.logger.info('Loading configuration from %s' % self.configfile)
        self.config = ConfigParser()
        self.config['DEFAULT'] = { 'socket_path': DEFAULT_SOCK_PATH }
        if os.path.exists(self.configfile):
            try:
                self.config.read(self.configfile)
            except Exception as e:
                self.logger.warning(str(e))
        cdir = Path(DEFAULT_CONFIG_DIR)
        if cdir.is_dir():
            for configfile in sorted([x for x in cdir.iterdir() if x.is_file()]):
                self.logger.info('Loading configuration from %s' % configfile)
                try:
                    self.config.read(configfile)
                except Exception as e:
                    self.logger.warning(str(e))
        if not self.config.has_section('global'):
            self.config.add_section('global')

    def handle_msg_recv(self, conn):
        msg = b''
        while True:
            try:
                data = conn.recv(1024)
            except Exception as e:
                self.logger.error('Failed receiving data from socket')
                return
            if len(data) == 0:
                self.logger.debug('No more bytes received, we have completed')
                break
            elif len(data) == 1024:
                msg += data
                self.logger.debug('Filled 1024 bytes, continuing')
                continue
            else:
                msg += data
                self.logger.debug('Filled %d bytes, complete' % len(data))
                break
        return json.loads(msg)

    def fetch_tenant_app_ids(self, uname):
        # Get the tenant and app ids from the config
        if not self.config.has_option('global', 'tenant_id'):
            self.logger.error('The tenant id was not set in the configuration')
            raise ConfigError()
        tenant_id = self.config.get('global', 'tenant_id')
        if not self.config.has_option('global', 'app_id'):
            self.logger.error('The app id was not set in the configuration')
            raise ConfigError()
        app_id = self.config.get('global', 'app_id')
        # TODO: Check for domain specific tenant and app ids
        return tenant_id, app_id

    def handle_nss_account_by_name(self, uname):
        random.seed(uname)
        uid = random.randint(10000, 500000)
        return {
            'name': uname,
            'uid': uid,
            'gid': uid,
            'gecos': uname,
            'homedir': '/home/%s' % uname,
            'shell': '/bin/bash'
        }

    def handle_authenticate(self, uname, passwd):
        try:
            tenant_id, app_id = self.fetch_tenant_app_ids(uname)
        except ConfigError:
            return None

        # Create the app for connecting to Azure AD
        authority_url = 'https://login.microsoftonline.com/%s' % tenant_id
        app = PublicClientApplication(app_id, authority=authority_url)

        # Authenticate to Azure AD
        token = app.acquire_token_by_username_password(uname, passwd, [])
        if 'access_token' in token.keys():
            self.logger.info('Authentication successful for user "%s"' % uname)
        elif 'error_codes' in token.keys() and AzureError.INVALID_USER in token['error_codes']:
            return None
        else:
            if 'error_codes' in token.keys():
                if AzureError.REQUIRES_MFA in token['error_codes']:
                    self.logger.info('Azure AD application requires MFA')
                    token = app.acquire_token_interactive([], login_hint=uname)
                    if 'access_token' in token.keys():
                        self.logger.info('Authentication successful for user "%s"' % uname)
                        return True
                if AzureError.NO_CONSENT in token['error_codes']:
                    url = '%s/adminconsent?client_id=%s' % (authority_url, app_id)
                    self.logger.error('Azure AD application requires consent,' +
                                      ' either from tenant, or from user.' +
                                      'If you\'re a tenant\'s administrator,' +
                                      ' go to: ' + url)
                if AzureError.NO_SECRET in token['error_codes']:
                    url = 'https://learn.microsoft.com/en-us/azure/' + \
                        'active-directory/develop/scenario-desktop-app' + \
                        '-registration#redirect-uris'
                    self.logger.error('Azure AD application requires enabling' +
                                      ' \'Allow public client flows\'. ' + url)
            if 'error_description' in token.keys():
                self.logger.error(token['error_description'])
            return False
        return True

    def handle_msg_resp(self, msg):
        resp = {}
        if type(msg) == dict and 'PamAuthenticate' in msg.keys():
            resp['PamStatus'] = self.handle_authenticate(*tuple(msg['PamAuthenticate']))
        if type(msg) == dict and 'NssAccountByName' in msg.keys():
            resp['NssAccount'] = self.handle_nss_account_by_name(msg['NssAccountByName'])
        self.logger.debug(json.dumps(resp, indent=4))
        return json.dumps(resp).encode()

    def run(self):
        socket_path = self.config.get('global', 'socket_path')
        if os.path.exists(socket_path):
            os.remove(socket_path)
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.bind(socket_path)
        while True:
            sock.listen(1)
            conn, addr = sock.accept()
            msg = self.handle_msg_recv(conn)
            if type(msg) == dict and 'PamAuthenticate' in msg.keys():
                # Censor the password from the logs
                self.logger.debug(json.dumps({'PamAuthenticate': [
                    msg['PamAuthenticate'][0], 'X'*10
                ]}, indent=4))
            else:
                self.logger.debug(json.dumps(msg, indent=4))
            resp = self.handle_msg_resp(msg)
            conn.send(resp)
            conn.close()

desc = '''
Himmelblau is an interoperability suite for Microsoft Azure AD and Intune.
The Himmelblau daemon is the primary communication interface between Azure
and the Linux PAM and NSS services.
'''

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("--configfile", "-s", help="Configuration file")
    parser.add_argument("--debuglevel", "-d",
                        help="Debug level. Default is WARNING.",
                        choices=['CRITICAL', 'ERROR', 'WARNING',
                                 'INFO', 'DEBUG', 'NOTSET'],
                        default='WARNING')
    parser.add_argument("--version", "-v", help="Display version number",
                        action="store_true")
    args = parser.parse_args()

    if args.version:
        print('himmelblau 0.1.0')
        exit(0)

    config = DEFAULT_CONFIG_PATH
    if args.configfile:
        config = args.configfile

    d = Himmelblaud(config, args.debuglevel)
    d.run()
